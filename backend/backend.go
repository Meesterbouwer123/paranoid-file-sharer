package backend

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"

	fileencryption "paranoid-file-sharer/utils/file_encryption"
)

func StartBackend() {
	// load commonly used files so we don't need to do file IO on each request
	cache := getCache()

	//index file
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.RequestURI != "/" && r.RequestURI != "/index.html" {
			notFound(w, r)
			return
		}
		w.Write(cache.index)
	})

	// download endpoint
	http.HandleFunc("/download/", func(w http.ResponseWriter, r *http.Request) {
		file := strings.TrimPrefix(r.RequestURI, "/download/")
		if r.Method != http.MethodGet || !fileencryption.IsValidFilename(file) {
			// incorrect api usage, inform the user
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("Incorrect API usage, expected to receive GET /download/:filename"))
			return
		}

		// we validated that the file was in fact one that could ahve been generated by our random filename generator
		data, err := os.ReadFile("uploads/" + file)
		if err != nil {
			// file probably not found
			fmt.Println(err)
			notFound(w, r)
			return
		}

		// decrypt file
		filename, mime_type, content, err := fileencryption.DecryptFile(data)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			w.Write([]byte("Something went wrong, we are investigating what"))
			log.Fatal(err)
		}

		w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))
		w.Header().Set("Content-Length", strconv.Itoa(len(content)))
		w.Header().Set("Content-Type", mime_type)

		w.Write(content)
	})

	// upload endpoint
	http.HandleFunc("/upload", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			// incorrect api usage, inform the user
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("Incorrect API usage, expected to receive POST /upload"))
			return
		}

		// 10 GB looks enough
		if r.ParseMultipartForm(10<<30) != nil {
			// incorrect api usage, inform the user
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("Incorrect API usage, could not read form data"))
			return
		}

		file, header, err := r.FormFile("file")
		if err != nil {
			// incorrect api usage, inform the user
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("Incorrect API usage, could not read form file"))
			return
		}

		// store file
		filename := fileencryption.GetFilename()
		data := make([]byte, header.Size)
		file.Read(data)
		encrypted := fileencryption.EncryptFile(header.Filename, http.DetectContentType(data), data)
		os.WriteFile("uploads/"+filename, encrypted, os.ModePerm)

		// return a link to the user
		link := fmt.Sprintf("%s:%s/download/%s", os.Getenv("INSTANCE_URL"), os.Getenv("PORT"), filename)

		w.Write([]byte(link))
	})

	log.Fatal(http.ListenAndServe(fmt.Sprintf(":%s", os.Getenv("PORT")), nil))
}

type Cache struct {
	index []byte
}

func getCache() Cache {
	index, err := os.ReadFile("site/index.html")
	if err != nil {
		log.Fatal(err)
	}

	return Cache{index: index}
}

// 404 handeler
func notFound(w http.ResponseWriter, _ *http.Request) {
	w.WriteHeader(http.StatusNotFound)
	w.Write([]byte("Sorry, this page doesn't exist"))
}
